import os,json
from flask import Flask, request, jsonify, Response, stream_with_context
from flask_pymongo import PyMongo
from flask_bcrypt import Bcrypt
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity
from dotenv import load_dotenv
from datetime import timedelta, datetime
import requests
from bson import ObjectId
# Load environment variables
load_dotenv()

MONGO_URI = os.getenv("MONGO_URI", "mongodb://localhost:27017/vuln_analyzer")
JWT_SECRET = os.getenv("JWT_SECRET", "super-secret-key")
API_KEY = os.getenv("API_KEY")
MODEL = os.getenv("MODEL")
BASE_URL = os.getenv("BASE_URL")
TEMPERATURE = float(os.getenv("TEMPERATURE", "0.6"))

app = Flask(__name__)
app.config["MONGO_URI"] = MONGO_URI
app.config["JWT_SECRET_KEY"] = JWT_SECRET
app.config["JWT_ACCESS_TOKEN_EXPIRES"] = timedelta(days=7)

mongo = PyMongo(app)
bcrypt = Bcrypt(app)
jwt = JWTManager(app)

# --- User Authentication ---
@app.route('/signup', methods=['POST'])
def signup():
    data = request.json
    username = data.get('username')
    password = data.get('password')
    if not username or not password:
        return jsonify({"msg": "Username and password required."}), 400
    if mongo.db.users.find_one({"username": username}):
        return jsonify({"msg": "Username already exists."}), 400
    pw_hash = bcrypt.generate_password_hash(password).decode('utf-8')
    mongo.db.users.insert_one({
        "username": username, 
        "password": pw_hash, 
        "conversations": []
    })
    return jsonify({"msg": "User created successfully."}), 201

@app.route('/login', methods=['POST'])
def login():
    data = request.json
    username = data.get('username')
    password = data.get('password')
    user = mongo.db.users.find_one({"username": username})
    if not user or not bcrypt.check_password_hash(user['password'], password):
        return jsonify({"msg": "Invalid username or password."}), 401
    access_token = create_access_token(identity=str(user['_id']))
    return jsonify({"access_token": access_token, "username": username}), 200



# --- Chat Conversations ---
@app.route('/conversations/new', methods=['POST'])
@jwt_required()
def create_conversation():
    user_id = get_jwt_identity()
    user = mongo.db.users.find_one({"_id": ObjectId(user_id)})
    if not user:
        return jsonify({"msg": "User not found."}), 404
    
    data = request.json
    title = data.get('title', 'New Conversation')
    
    # Create a new conversation with proper ISO format dates
    current_time = datetime.utcnow().isoformat() + "Z"
    new_conversation = {
        "id": str(ObjectId()),
        "title": title,
        "created_at": current_time,
        "updated_at": current_time,
        "messages": []
    }
    
    # Add to user's conversations
    conversations = user.get('conversations', [])
    conversations.append(new_conversation)
    
    # Update user document
    mongo.db.users.update_one(
        {"_id": ObjectId(user_id)},
        {"$set": {"conversations": conversations}}
    )
    
    return jsonify({"conversation": new_conversation}), 201

@app.route('/conversations', methods=['GET'])
@jwt_required()
def get_conversations():
    user_id = get_jwt_identity()
    user = mongo.db.users.find_one({"_id": ObjectId(user_id)})
    if not user:
        return jsonify({"msg": "User not found."}), 404
    
    # Return just the conversation metadata, not all messages
    conversations = user.get('conversations', [])
    conversation_list = [
        {
            "id": conv["id"],
            "title": conv["title"],
            "created_at": conv["created_at"],
            "updated_at": conv["updated_at"],
            "message_count": len(conv.get("messages", []))
        }
        for conv in conversations
    ]
    
    return jsonify({"conversations": conversation_list}), 200

@app.route('/conversations/<conversation_id>', methods=['GET'])
@jwt_required()
def get_conversation(conversation_id):
    user_id = get_jwt_identity()
    user = mongo.db.users.find_one({"_id": ObjectId(user_id)})
    if not user:
        return jsonify({"msg": "User not found."}), 404
    
    # Find the conversation
    conversation = next(
        (conv for conv in user.get('conversations', []) if conv["id"] == conversation_id),
        None
    )
    
    if not conversation:
        return jsonify({"msg": "Conversation not found."}), 404
    
    return jsonify({"conversation": conversation}), 200

@app.route('/conversations/<conversation_id>', methods=['DELETE'])
@jwt_required()
def delete_conversation(conversation_id):
    user_id = get_jwt_identity()
    user = mongo.db.users.find_one({"_id": ObjectId(user_id)})
    if not user:
        return jsonify({"msg": "User not found."}), 404
    
    # Filter out the conversation to delete
    conversations = [
        conv for conv in user.get('conversations', [])
        if conv["id"] != conversation_id
    ]
    
    # Update user document
    mongo.db.users.update_one(
        {"_id": ObjectId(user_id)},
        {"$set": {"conversations": conversations}}
    )
    
    return jsonify({"msg": "Conversation deleted."}), 200

@app.route('/conversations/<conversation_id>/rename', methods=['PUT'])
@jwt_required()
def rename_conversation(conversation_id):
    user_id = get_jwt_identity()
    user = mongo.db.users.find_one({"_id": ObjectId(user_id)})
    if not user:
        return jsonify({"msg": "User not found."}), 404
    
    data = request.json
    new_title = data.get('title')
    if not new_title:
        return jsonify({"msg": "Title required."}), 400
    
    # Check for case-sensitive duplicate
    for conv in user.get('conversations', []):
        if conv["title"] == new_title and conv["id"] != conversation_id:
            return jsonify({"msg": "A conversation with this name already exists."}), 409
    
    # Find and update the conversation
    conversations = user.get('conversations', [])
    for conv in conversations:
        if conv["id"] == conversation_id:
            conv["title"] = new_title
            conv["updated_at"] = datetime.utcnow().isoformat() + "Z"
            break
    else:
        return jsonify({"msg": "Conversation not found."}), 404
    
    # Update user document
    mongo.db.users.update_one(
        {"_id": ObjectId(user_id)},
        {"$set": {"conversations": conversations}}
    )
    
    return jsonify({"msg": "Conversation renamed."}), 200

@app.route('/conversations/search', methods=['GET'])
@jwt_required()
def search_conversations():
    user_id = get_jwt_identity()
    user = mongo.db.users.find_one({"_id": ObjectId(user_id)})
    if not user:
        return jsonify({"msg": "User not found."}), 404

    query = request.args.get('q', '').strip().lower()
    if not query:
        return jsonify({"results": []})

    conversations = user.get('conversations', [])
    results = []

    # First, search by conversation title
    for conv in conversations:
        if query in conv.get('title', '').lower():
            results.append({
                "id": conv["id"],
                "title": conv["title"],
                "match_type": "title",
                "snippet": None,
                "created_at": conv["created_at"],
                "updated_at": conv["updated_at"],
                "matches": [],
                "matchIndexes": []
            })

    # If no title matches, search inside messages (collect all matches per conversation)
    if not results:
        for conv in conversations:
            matches = []
            match_indexes = []
            for idx, msg in enumerate(conv.get('messages', [])):
                content = msg.get('content', '')
                if query in content.lower():
                    snippet = content
                    # Optionally, shorten the snippet
                    if len(snippet) > 80:
                        idx_query = snippet.lower().index(query)
                        start = max(0, idx_query - 30)
                        end = min(len(snippet), idx_query + len(query) + 30)
                        snippet = snippet[start:end]
                        if start > 0:
                            snippet = '...' + snippet
                        if end < len(content):
                            snippet = snippet + '...'
                    matches.append(snippet)
                    match_indexes.append(idx)
            if matches:
                results.append({
                    "id": conv["id"],
                    "title": conv["title"],
                    "match_type": "message",
                    "snippet": matches[0],
                    "created_at": conv["created_at"],
                    "updated_at": conv["updated_at"],
                    "matches": matches,
                    "matchIndexes": match_indexes
                })

    return jsonify({"results": results}), 200

# --- Modified Chat Endpoint ---
@app.route('/chat/<conversation_id>', methods=['POST'])
@jwt_required()
def chat(conversation_id):
    user_id = get_jwt_identity()
    user = mongo.db.users.find_one({"_id": ObjectId(user_id)})
    if not user:
        return jsonify({"msg": "User not found."}), 404

    conversations = user.get('conversations', [])
    conversation_index = None
    conversation = None

    for i, conv in enumerate(conversations):
        if conv["id"] == conversation_id:
            conversation = conv
            conversation_index = i
            break

    if conversation is None:
        return jsonify({"msg": "Conversation not found."}), 404

    data = request.json
    message = data.get('message', '').strip()
    if not message:
        return jsonify({"msg": "Message required."}), 400

    messages = conversation.get('messages', [])

    # Update timestamp
    current_time = datetime.utcnow().isoformat() + "Z"
    conversation["updated_at"] = current_time

    system_prompt = (
        "You are Moktashif, a smart and friendly cybersecurity assistant.\n"
        "You are strictly limited to answering only cybersecurity-related questions.\n"
        "If a user asks anything not related to cybersecurity — including famous people, sports, general trivia, or personal questions — you must politely refuse.\n"
        "Say: 'I can only help with cybersecurity topics. Please ask something related to web security, hacking, threats, or protection.'\n"
        "Do not provide answers outside the domain, even if you know them. Never break character.\n"
        "Use a warm, human tone with short, clear answers. You can be casual or slightly witty when appropriate, especially in greetings or small talk.\n"
        "Introduce yourself as 'Moktashif' only when it makes sense — such as during first-time greetings, re-engagement after a pause, or if the user asks who you are.\n"
        "Don't overuse your name. Vary your language like a real human would.\n"
        "Avoid technical jargon unless the user clearly understands it. Always favor helpful explanations over buzzwords.\n"
        "Do not break character or explain that you're an AI. Stay in role as Moktashif.\n"
        "Do not hallucinate or provide false information regarding the security field like if the user have asked you about new cve or new tools just tell them that you don't know.\n"
        "If the user asks about something recent, breaking, or requests the latest information, you may use live web search results if available.\n"
        "If you do not have enough information to answer, you may request to use the web search feature.\n"
    )

    # Prepare LLM message history
    llm_messages = [{"role": "system", "content": system_prompt}]

    # Add recent messages for context
    for msg in messages[-10:]:
        llm_messages.append({"role": msg["role"], "content": msg["content"]})

    llm_messages.append({"role": "user", "content": message})

    payload = {
        "model": MODEL,
        "messages": llm_messages,
        "temperature": TEMPERATURE,
        "stream": True  # Streaming enabled
    }

    headers = {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json"
    }

    def generate():
        import sys
        import json
        # Save user message immediately
        messages.append({"role": "user", "content": message})
        conversation["messages"] = messages
        conversation["updated_at"] = current_time
        conversations[conversation_index] = conversation
        mongo.db.users.update_one(
            {"_id": ObjectId(user_id)},
            {"$set": {"conversations": conversations}}
        )

        # Variables to track response outside the try block
        partial_reply = ""
        error_occurred = False

        try:
            with requests.post(f"{BASE_URL}/chat/completions", json=payload, headers=headers, stream=True) as resp:
                resp.raise_for_status()
                
                for chunk in resp.iter_lines():
                    if not chunk:
                        continue
                    line = chunk.decode()
                    if line.startswith("data: "):
                        line = line[len("data: "):]
                    if line.strip() == "[DONE]":
                        break
                    try:
                        data = json.loads(line)
                        delta = data.get("choices", [{}])[0].get("delta", {}).get("content", "")
                        if delta:
                            partial_reply += delta
                            # Print to terminal for local debugging
                            print(delta, end="", flush=True)
                            # Send to client without buffering
                            yield delta
                    except Exception as e:
                        print(f"Stream parse error: {e}", file=sys.stderr)
                        continue
                
                # Print newline after completion in terminal
                print()
        except Exception as e:
            error_msg = f"[ERROR] LLM API error: {e}"
            print(error_msg, file=sys.stderr)
            partial_reply = error_msg
            error_occurred = True
            yield error_msg
        finally:
            # Save the assistant reply after all streaming is complete
            if partial_reply:  # Only save if we got a response
                # Add the assistant message to the conversation
                messages.append({"role": "assistant", "content": partial_reply})
                conversation["messages"] = messages
                conversation["updated_at"] = current_time
                conversations[conversation_index] = conversation
                
                # Update in the database
                update_result = mongo.db.users.update_one(
                    {"_id": ObjectId(user_id)},
                    {"$set": {"conversations": conversations}}
                )
                print(f"Database update completed. Modified: {update_result.modified_count}")

    return Response(stream_with_context(generate()), mimetype='text/plain')


# --- Legacy Endpoint (Unchanged Logic, Still Points to Updated Chat) ---
@app.route('/chat', methods=['POST'])
@jwt_required()
def legacy_chat():
    user_id = get_jwt_identity()
    user = mongo.db.users.find_one({"_id": ObjectId(user_id)})
    if not user:
        return jsonify({"msg": "User not found."}), 404

    # Create a new conversation if user doesn't have any
    conversations = user.get('conversations', [])
    if not conversations:
        current_time = datetime.utcnow().isoformat() + "Z"
        new_conversation = {
            "id": str(ObjectId()),
            "title": "New Conversation",
            "created_at": current_time,
            "updated_at": current_time,
            "messages": []
        }
        conversations.append(new_conversation)
        mongo.db.users.update_one(
            {"_id": ObjectId(user_id)},
            {"$set": {"conversations": conversations}}
        )
        conversation_id = new_conversation["id"]
    else:
        # Use the most recent conversation
        conversation_id = conversations[-1]["id"]

    # Forward to the updated chat endpoint
    return chat(conversation_id)

if __name__ == '__main__':
    app.run(debug=True)
